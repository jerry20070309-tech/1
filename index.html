async function fetchData(s) {
    try {
        const [kRes, fRes, oRes, tRes] = await Promise.all([
            fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${s}&interval=5m&limit=100`),
            fetch(`https://fapi.binance.com/fapi/v1/premiumIndex?symbol=${s}`),
            fetch(`https://fapi.binance.com/fapi/v1/openInterest?symbol=${s}`),
            fetch(`https://fapi.binance.com/fapi/v1/ticker/bookTicker?symbol=${s}`) 
        ]);
        const k = await kRes.json(), f = await fRes.json(), o = await oRes.json(), t = await tRes.json();

        // 【訂單簿篩選條件：升級為 2k 級別】
        const bid = parseFloat(t.bidPrice);
        const ask = parseFloat(t.askPrice);
        const spread = (ask - bid) / bid;
        
        // 1. 嚴格價差過濾：0.15% (確保買賣掛單極度緊湊，避免 1k~2k 的單子就打穿價格)
        if (spread > 0.0015) return null; 

        // 2. 嚴格成交量過濾：24h 成交額必須 > 10,000,000 USDT
        const v24hEstimate = k.reduce((a, b) => a + parseFloat(b[5]), 0) * (288 / 100);
        if (v24hEstimate < 10000000) return null;

        // --- 以下原本策略程式碼完全保持不動 ---
        const prices = k.map(x => parseFloat(x[4]));
        const lastP = prices[prices.length-1];
        const vNow = parseFloat(k[k.length-1][5]);
        const vAvg = k.slice(-20).reduce((a,b)=>a+parseFloat(b[5]),0)/20;
        
        const pDelta = Math.abs(lastP - prices[prices.length-2]) / prices[prices.length-2];
        const vDelta = Math.abs(vNow - (stats[s]?.lastV || vNow));
        const drvRaw = vDelta > 0 ? (pDelta / vDelta) * 100000000 : 0;

        const ma7 = calcMA(prices, 7), ma25 = calcMA(prices, 25), ma99 = calcMA(prices, 99);
        const maSqz = (Math.max(ma7, ma25, ma99) - Math.min(ma7, ma25, ma99)) / Math.min(ma7, ma25, ma99);

        const peakIdx = k.reduce((maxI, x, i, arr) => (parseFloat(x[2])-parseFloat(x[3]) > parseFloat(arr[maxI][2])-parseFloat(arr[maxI][3]) ? i : maxI), 0);
        const poc = calcPOC(k.slice(peakIdx));

        if(!stats[s]) stats[s] = { frHist: [] };
        stats[s].frHist.push(parseFloat(f.lastFundingRate));
        if(stats[s].frHist.length > 20) stats[s].frHist.shift();
        const slope = (stats[s].frHist[stats[s].frHist.length-1] - stats[s].frHist[0]) / (Math.abs(stats[s].frHist[0]) || 0.0001);

        stats[s].lastV = vNow;

        return {
            s, price: lastP, poc, slope, drv: drvRaw, 
            maSqz, oi: parseFloat(o.openInterest), volR: vNow/vAvg,
            isPocBrk: lastP > poc && vNow > vAvg * 1.5,
            isSqz: maSqz < FILTER.SQZ,
            isSqzOrder: ma7 > ma25 && ma25 > ma99
        };
    } catch(e) { return null; }
}
